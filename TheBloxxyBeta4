local Players = game:GetService("Players")
local PhysicsService = game:GetService("PhysicsService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")
local playerGui = player:WaitForChild("PlayerGui")
local dashElement = playerGui:FindFirstChild("Mobile") and playerGui.Mobile:FindFirstChild("Dash")
local runElement = playerGui:FindFirstChild("Mobile") and playerGui.Mobile:FindFirstChild("Run")

if not dashElement then
    warn("Dash UI não encontrado!")
    return
end

local clonedElement = dashElement:Clone()
local clonedElement2 = runElement:Clone()


local function pullPlayerToHighPosition()

    local player = Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart")

    local lookVector = rootPart.CFrame.LookVector
    local forwardOffset = Vector3.new(lookVector.X * 200, 0, lookVector.Z * 30) -- 30 unidades à frente, ignorando Y
    local highPosition = rootPart.Position + forwardOffset + Vector3.new(0, 100, 0) -- Mantém a altura +100
    rootPart.CFrame = CFrame.new(highPosition, highPosition + Vector3.new(lookVector.X, 0, lookVector.Z)) -- Mantém a direção
end

local function createInvisibleFloor()
    local floor = Instance.new("Part")
    floor.Size = Vector3.new(8, 1, 8)
    floor.Position = Vector3.new(rootPart.Position.X, rootPart.Position.Y - 1, rootPart.Position.Z)
    floor.Anchored = true
    floor.Transparency = 0.75
    floor.CanCollide = true
    floor.CanTouch = false
    floor.CanQuery = false
    floor.Parent = workspace

    -- Grupo de colisão
    if not pcall(function() PhysicsService:CreateCollisionGroup("PlayerFloor") end) then
        warn("Grupo PlayerFloor já existe")
    end
    if not pcall(function() PhysicsService:CreateCollisionGroup("Player") end) then
        warn("Grupo Player já existe")
    end

    PhysicsService:SetPartCollisionGroup(floor, "PlayerFloor")
    PhysicsService:SetPartCollisionGroup(rootPart, "Player")
    for i = 1, 5 do

    pcall(function()   
            selectedTarget = getNearestPlayer()


            if selectedTarget and selectedTarget.Character and selectedTarget.Character:FindFirstChild("HumanoidRootPart") then
                local targetPosition = selectedTarget.Character.HumanoidRootPart.Position
                local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")

                if root then
                    local distance = (targetPosition - root.Position).Magnitude
                    local offsetHeight = 0
                    local proportionalOffset = -2

                    targetPosition = targetPosition + Vector3.new(0, proportionalOffset, 0)
                    Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPosition)

                end
            end
        end)
        task.wait(0.1)
    end
    -- Espera 4 segundos antes do fade out
    task.wait(9)

    -- Animação de fade out em 1 segundo
    local fadeInfo = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    local fadeGoal = {Transparency = 1}
    local fadeTween = TweenService:Create(floor, fadeInfo, fadeGoal)
    fadeTween:Play()
    fadeTween.Completed:Wait()

    floor:Destroy()
end

clonedElement.Size = UDim2.new(0.18, 0, 0.18, 0)
clonedElement.Position = UDim2.new(0.35, 0, 0.6, 0)

clonedElement2.Size = UDim2.new(0.18, 0, 0.18, 0)
clonedElement2.Position = UDim2.new(0.6, 0, 0.6, 0)

for _, connection in pairs(getconnections(clonedElement.MouseButton1Click)) do
    connection:Disable()
end

for _, connection in pairs(getconnections(clonedElement2.MouseButton1Click)) do
    connection:Disable()
end

clonedElement.MouseButton1Down:Connect(function()
    print("Novo clique detectado no elemento clonado!")
        NS = true
    clonedElement.Active = false
    pullPlayerToHighPosition()
    createInvisibleFloor()
    clonedElement.Active = true
        task.wait(1)
        NS = false
end)

clonedElement2.MouseButton1Down:Connect(function()
        task.wait(1)
        if selectedTarget then
            task.spawn(function()
                    for i = 1, 80 do

            local player = game.Players.LocalPlayer
            local character = player.Character or player.CharacterAdded:Wait()
            local targetPosition = selectedTarget.Character.HumanoidRootPart.Position
            local direction = (character.HumanoidRootPart.Position - targetPosition).unit
            local newPosition = targetPosition + direction * -15  -- 5 unidades atrás do alvo
            character:SetPrimaryPartCFrame(CFrame.new(newPosition))
                        task.wait()
                end
                end)
            for i = 1, 200 do

            pcall(function()   
                selectedTarget = getNearestPlayer()


                if selectedTarget and selectedTarget.Character and selectedTarget.Character:FindFirstChild("HumanoidRootPart") then
                    local targetPosition = selectedTarget.Character.HumanoidRootPart.Position
                    local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")

                    if root then
                        local distance = (targetPosition - root.Position).Magnitude
                        local offsetHeight = 0
                        local proportionalOffset = -2

                        targetPosition = targetPosition + Vector3.new(0, proportionalOffset, 0)
                        Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPosition)

                    end
                end
            end)

                task.wait()
                end

        end

end)



clonedElement.Parent = playerGui.Mobile
clonedElement2.Parent = playerGui.Mobile







local Player = game.Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")
local LocalPlayer = Player

 selectedTarget = nil -- Variável global para armazenar o alvo

-- Função para encontrar o jogador mais próximo
local function getNearestPlayer()
    local closestPlayer = nil
    local closestDistance = math.huge

    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= Player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (otherPlayer.Character.HumanoidRootPart.Position - Player.Character.HumanoidRootPart.Position).Magnitude
            if distance < closestDistance and (otherPlayer ~= selectedTarget or true) then
                closestDistance = distance
                closestPlayer = otherPlayer
            end
        end
    end
    return closestPlayer
end

-- Função chamada ao pressionar o botão
local function selectTarget()
    local newTarget = getNearestPlayer()

    if newTarget then
        selectedTarget = newTarget

    end
end


RunService.RenderStepped:Connect(function()
        selectedTarget = getNearestPlayer()


    if selectedTarget and selectedTarget.Character and selectedTarget.Character:FindFirstChild("HumanoidRootPart") then
        local targetPosition = selectedTarget.Character.HumanoidRootPart.Position
        local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")

        if root and clicking then
            local distance = (targetPosition - root.Position).Magnitude
            local offsetHeight = 0
            local proportionalOffset = -2

            targetPosition = targetPosition + Vector3.new(0, proportionalOffset, 0)
            Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPosition)

        end
    end


        pcall(function()
if NS then
                for _, obj in pairs(humanoidRootPart:GetChildren()) do
                    if obj:IsA("BodyVelocity") or obj:IsA("BodyGyro") or
                       obj:IsA("BodyPosition") or obj:IsA("BodyAngularVelocity") or
                       obj:IsA("BodyThrust") or obj:IsA("BodyForce") then
                        obj.Velocity = Vector3.new(0, 0, 0)
                        obj.AngularVelocity = Vector3.new(0, 0, 0)
                        if obj:IsA("BodyPosition") then
                            obj.Position = humanoidRootPart.Position
                        end
                        if obj:IsA("BodyGyro") then
                            obj.CFrame = humanoidRootPart.CFrame
                        end
                        if obj:IsA("BodyThrust") or obj:IsA("BodyForce") then
                            obj.Force = Vector3.new(0, 0, 0)
                        end
                    end
                end
                end
            end)
end)


local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Criando a área invisível
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = PlayerGui

local touchArea = Instance.new("Frame")
touchArea.Size = UDim2.new(0.3, 0, 0.3, 0) -- Ajuste o tamanho
touchArea.Position = UDim2.new(0.5, 0, -0.1, 0) -- Ajuste a posição
touchArea.BackgroundTransparency = 0.9 -- Deixa invisível
touchArea.Active = true -- Permite interação sem bloquear o jogo
touchArea.Parent = screenGui

 clicking = false


-- Iniciar clique ao tocar na área
touchArea.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            clicking = true
    end
end)

-- Parar clique ao soltar
touchArea.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
        clicking = false
    end
end)








local Player = game.Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:FindFirstChildOfClass("Humanoid")

if Humanoid then
    local defaultWalkSpeed = Humanoid.WalkSpeed
    local targetSpeed = defaultWalkSpeed * 4

    -- Função para manter a velocidade
    local function maintainSpeed()
        while true do
            if Humanoid.WalkSpeed ~= targetSpeed then
                Humanoid.WalkSpeed = targetSpeed
            end
            task.wait(0.1) -- Pequeno intervalo para evitar sobrecarga
        end
    end

    -- Inicia a manutenção da velocidade
    task.spawn(maintainSpeed)
end


local Player = game.Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:FindFirstChildOfClass("Humanoid")

if Humanoid then
    local defaultWalkSpeed = Humanoid.WalkSpeed
    local targetSpeed = defaultWalkSpeed * 2.25
    local targetJumpPower = Humanoid.JumpPower * 2.5
    Humanoid.UseJumpPower = true
    Humanoid.JumpPower = targetJumpPower

    -- Função para manter a velocidade e o pulo
    local function maintainAttributes()
        while true do
            if Humanoid.WalkSpeed ~= targetSpeed then
                Humanoid.WalkSpeed = targetSpeed
            end
            if Humanoid.JumpPower ~= targetJumpPower then
                Humanoid.JumpPower = targetJumpPower
            end
            Humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true) -- Permite pulo infinito
            task.wait(0.1) -- Pequeno intervalo para evitar sobrecarga
        end
    end

    -- Inicia a manutenção dos atributos
    task.spawn(maintainAttributes)
end


function onJumpRequest()
    game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass("Humanoid"):ChangeState(
        "Jumping"
    )
end

    connection = game:GetService("UserInputService").JumpRequest:connect(onJumpRequest)
