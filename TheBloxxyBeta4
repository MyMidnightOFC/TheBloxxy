local Players = game:GetService("Players")
local PhysicsService = game:GetService("PhysicsService")
local TweenService = game:GetService("TweenService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local rootPart = character:WaitForChild("HumanoidRootPart")
local playerGui = player:WaitForChild("PlayerGui")
local dashElement = playerGui:FindFirstChild("Mobile") and playerGui.Mobile:FindFirstChild("Dash")
local runElement = playerGui:FindFirstChild("Mobile") and playerGui.Mobile:FindFirstChild("Run")

if not dashElement then
    warn("Dash UI não encontrado!")
    return
end

local clonedElement = dashElement:Clone()
local clonedElement2 = runElement:Clone()

local function pullPlayerToHighPosition()
    local player = Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local rootPart = character:WaitForChild("HumanoidRootPart")

    local lookVector = rootPart.CFrame.LookVector
    local forwardOffset = Vector3.new(lookVector.X * 200, 0, lookVector.Z * 30) -- 30 unidades à frente, ignorando Y
    local highPosition = rootPart.Position + forwardOffset + Vector3.new(0, 100, 0) -- Mantém a altura +100
    rootPart.CFrame = CFrame.new(highPosition, highPosition + Vector3.new(lookVector.X, 0, lookVector.Z)) -- Mantém a direção
end

local function createInvisibleFloor()
    local floor = Instance.new("Part")
    floor.Size = Vector3.new(8, 1, 8)
    floor.Position = Vector3.new(rootPart.Position.X, rootPart.Position.Y - 1, rootPart.Position.Z)
    floor.Anchored = true
    floor.Transparency = 0.75
    floor.CanCollide = true
    floor.CanTouch = false
    floor.CanQuery = false
    floor.Parent = workspace

    -- Grupo de colisão
    if
        not pcall(
            function()
                PhysicsService:CreateCollisionGroup("PlayerFloor")
            end
        )
     then
        warn("Grupo PlayerFloor já existe")
    end
    if
        not pcall(
            function()
                PhysicsService:CreateCollisionGroup("Player")
            end
        )
     then
        warn("Grupo Player já existe")
    end

    PhysicsService:SetPartCollisionGroup(floor, "PlayerFloor")
    PhysicsService:SetPartCollisionGroup(rootPart, "Player")
    for i = 1, 5 do
        pcall(
            function()
                selectedTarget = getNearestPlayer()

                if
                    selectedTarget and selectedTarget.Character and
                        selectedTarget.Character:FindFirstChild("HumanoidRootPart")
                 then
                    local targetPosition = selectedTarget.Character.HumanoidRootPart.Position
                    local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")

                    if root then
                        local distance = (targetPosition - root.Position).Magnitude
                        local offsetHeight = 0
                        local proportionalOffset = -2

                        targetPosition = targetPosition + Vector3.new(0, proportionalOffset, 0)
                        Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPosition)
                    end
                end
            end
        )
        task.wait(0.1)
    end
    -- Espera 4 segundos antes do fade out
    task.wait(9)

    -- Animação de fade out em 1 segundo
    local fadeInfo = TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
    local fadeGoal = {Transparency = 1}
    local fadeTween = TweenService:Create(floor, fadeInfo, fadeGoal)
    fadeTween:Play()
    fadeTween.Completed:Wait()

    floor:Destroy()
end

clonedElement.Size = UDim2.new(0.18, 0, 0.18, 0)
clonedElement.Position = UDim2.new(0.35, 0, 0.6, 0)

clonedElement2.Size = UDim2.new(0.18, 0, 0.18, 0)
clonedElement2.Position = UDim2.new(0.6, 0, 0.6, 0)

for _, connection in pairs(getconnections(clonedElement.MouseButton1Click)) do
    connection:Disable()
end

for _, connection in pairs(getconnections(clonedElement2.MouseButton1Click)) do
    connection:Disable()
end

clonedElement.MouseButton1Down:Connect(
    function()
        print("Novo clique detectado no elemento clonado!")
        NS = true
        View = true
        task.spawn(function()
                task.wait(0.2)
                NS = false
                View = false
            end)
        clonedElement.Active = false
        pullPlayerToHighPosition()
        createInvisibleFloor()
        clonedElement.Active = true
       
    end
)

clonedElement2.MouseButton1Down:Connect(
    function()
        task.wait(1)
      TP = true
        View = true 
        task.wait(1.45)
        TP = false
        View = false
    end
)

clonedElement.Parent = playerGui.Mobile
clonedElement2.Parent = playerGui.Mobile

local Player = game.Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Camera = workspace.CurrentCamera
local RunService = game:GetService("RunService")
local LocalPlayer = Player

selectedTarget = nil -- Variável global para armazenar o alvo

-- Função para encontrar o jogador mais próximo
local function getNearestPlayer()
    local closestPlayer = nil
    local closestDistance = math.huge

    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= Player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local distance =
                (otherPlayer.Character.HumanoidRootPart.Position - Player.Character.HumanoidRootPart.Position).Magnitude
            if distance < closestDistance and (otherPlayer ~= selectedTarget or true) then
                closestDistance = distance
                closestPlayer = otherPlayer
            end
        end
    end
    return closestPlayer
end

-- Função chamada ao pressionar o botão
local function selectTarget()
    local newTarget = getNearestPlayer()

    if newTarget then
        selectedTarget = newTarget
    end
end

RunService.RenderStepped:Connect(
    function()
        pcall(
            function()
        selectedTarget = getNearestPlayer()

        if selectedTarget and selectedTarget.Character and selectedTarget.Character:FindFirstChild("HumanoidRootPart") then
            local targetPosition = selectedTarget.Character.HumanoidRootPart.Position
            local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")

            if root and clicking then
                local distance = (targetPosition - root.Position).Magnitude
                local offsetHeight = 0
                local proportionalOffset = -2

                targetPosition = targetPosition + Vector3.new(0, proportionalOffset, 0)
                Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPosition)
            end
        end
            end)


        pcall(
            function()
                selectedTarget = getNearestPlayer()

                if
                    selectedTarget and selectedTarget.Character and
                        selectedTarget.Character:FindFirstChild("HumanoidRootPart") and View
                 then
                    local targetPosition = selectedTarget.Character.HumanoidRootPart.Position
                    local root =
                        LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")

                    if root then
                        local distance = (targetPosition - root.Position).Magnitude
                        local offsetHeight = 0
                        local proportionalOffset = 0

                        targetPosition = targetPosition + Vector3.new(0, proportionalOffset, 0)
                        Camera.CFrame = CFrame.new(Camera.CFrame.Position, targetPosition)
                    end
                end
            end
        )

        pcall(
        function()
                if selectedTarget and TP then
                    local player = game.Players.LocalPlayer
                    local character = player.Character or player.CharacterAdded:Wait()
                    local targetPosition = selectedTarget.Character.HumanoidRootPart.Position
                    local direction = (character.HumanoidRootPart.Position - targetPosition).unit
                    local newPosition = targetPosition + direction * -10 -- 5 unidades atrás do alvo
                    character:SetPrimaryPartCFrame(CFrame.new(newPosition))
                    task.wait()
                end
            end
        )
        

        pcall(
            function()
                if NS then
                    for _, obj in pairs(humanoidRootPart:GetChildren()) do
                        if
                            obj:IsA("BodyVelocity") or obj:IsA("BodyGyro") or obj:IsA("BodyPosition") or
                                obj:IsA("BodyAngularVelocity") or
                                obj:IsA("BodyThrust") or
                                obj:IsA("BodyForce")
                         then
                            obj.Velocity = Vector3.new(0, 0, 0)
                            obj.AngularVelocity = Vector3.new(0, 0, 0)
                            if obj:IsA("BodyPosition") then
                                obj.Position = humanoidRootPart.Position
                            end
                            if obj:IsA("BodyGyro") then
                                obj.CFrame = humanoidRootPart.CFrame
                            end
                            if obj:IsA("BodyThrust") or obj:IsA("BodyForce") then
                                obj.Force = Vector3.new(0, 0, 0)
                            end
                        end
                    end
                end
            end
        )
    end
)

local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:WaitForChild("PlayerGui")

-- Criando a área invisível
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = PlayerGui
screenGui.ResetOnSpawn = false

local touchArea = Instance.new("Frame")
touchArea.Size = UDim2.new(0.3, 0, 0.3, 0) -- Ajuste o tamanho
touchArea.Position = UDim2.new(0.5, 0, -0.25, 0) -- Ajuste a posição
touchArea.BackgroundTransparency = 0.9 -- Deixa invisível
touchArea.Active = true -- Permite interação sem bloquear o jogo
touchArea.Parent = screenGui

clicking = false

-- Iniciar clique ao tocar na área
touchArea.InputBegan:Connect(
    function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            clicking = true
        end
    end
)

-- Parar clique ao soltar
touchArea.InputEnded:Connect(
    function(input)
        if input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1 then
            clicking = false
        end
    end
)

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer

local function setupCharacter(character)
    local humanoid = character:WaitForChild("Humanoid")

    -- Definir valores padrão
    local defaultWalkSpeed = humanoid.WalkSpeed
    local targetSpeed = defaultWalkSpeed * 4.5
    local targetJumpPower = humanoid.JumpPower * 2.7

    humanoid.UseJumpPower = true
    humanoid.JumpPower = targetJumpPower

    -- Função para manter atributos
    task.spawn(
        function()
            while humanoid.Parent do
                humanoid.WalkSpeed = targetSpeed
                humanoid.JumpPower = targetJumpPower
                humanoid:SetStateEnabled(Enum.HumanoidStateType.Jumping, true) -- Pulo infinito
                task.wait(0.1)
            end
        end
    )

    -- Pulo infinito
    UserInputService.JumpRequest:Connect(
        function()
            if humanoid.Parent then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    )
end

-- Aplicar ao personagem atual
if player.Character then
    setupCharacter(player.Character)
end

-- Aplicar após reset
player.CharacterAdded:Connect(setupCharacter)

local uis = game:GetService("UserInputService")
local player = game:GetService("Players").LocalPlayer
local char = player.Character or player.CharacterAdded:Wait()
local humanoid = char:WaitForChild("Humanoid")

uis.JumpRequest:Connect(
    function()
        task.wait() -- Garante que o jogo processe o pulo normal antes de forçar outro
        if humanoid:GetState() ~= Enum.HumanoidStateType.Seated then
            humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
    end
)
